package programmatic

// Copyright (c) Microsoft and contributors.  All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

import (
	"encoding/json"
	"github.com/Azure/go-autorest/autorest"
	"github.com/Azure/go-autorest/autorest/date"
	"github.com/satori/go.uuid"
	"io"
)

// AzureRegions enumerates the values for azure regions.
type AzureRegions string

const (
	// Australiaeast ...
	Australiaeast AzureRegions = "australiaeast"
	// Brazilsouth ...
	Brazilsouth AzureRegions = "brazilsouth"
	// Eastasia ...
	Eastasia AzureRegions = "eastasia"
	// Eastus ...
	Eastus AzureRegions = "eastus"
	// Eastus2 ...
	Eastus2 AzureRegions = "eastus2"
	// Northeurope ...
	Northeurope AzureRegions = "northeurope"
	// Southcentralus ...
	Southcentralus AzureRegions = "southcentralus"
	// Southeastasia ...
	Southeastasia AzureRegions = "southeastasia"
	// Westcentralus ...
	Westcentralus AzureRegions = "westcentralus"
	// Westeurope ...
	Westeurope AzureRegions = "westeurope"
	// Westus ...
	Westus AzureRegions = "westus"
	// Westus2 ...
	Westus2 AzureRegions = "westus2"
)

// PossibleAzureRegionsValues returns an array of possible values for the AzureRegions const type.
func PossibleAzureRegionsValues() []AzureRegions {
	return []AzureRegions{Australiaeast, Brazilsouth, Eastasia, Eastus, Eastus2, Northeurope, Southcentralus, Southeastasia, Westcentralus, Westeurope, Westus, Westus2}
}

// OperationStatusType enumerates the values for operation status type.
type OperationStatusType string

const (
	// Failed ...
	Failed OperationStatusType = "Failed"
	// FAILED ...
	FAILED OperationStatusType = "FAILED"
	// Success ...
	Success OperationStatusType = "Success"
)

// PossibleOperationStatusTypeValues returns an array of possible values for the OperationStatusType const type.
func PossibleOperationStatusTypeValues() []OperationStatusType {
	return []OperationStatusType{Failed, FAILED, Success}
}

// ReadableType enumerates the values for readable type.
type ReadableType string

const (
	// ReadableTypeClosedListEntityExtractor ...
	ReadableTypeClosedListEntityExtractor ReadableType = "Closed List Entity Extractor"
	// ReadableTypeCompositeEntityExtractor ...
	ReadableTypeCompositeEntityExtractor ReadableType = "Composite Entity Extractor"
	// ReadableTypeEntityExtractor ...
	ReadableTypeEntityExtractor ReadableType = "Entity Extractor"
	// ReadableTypeHierarchicalChildEntityExtractor ...
	ReadableTypeHierarchicalChildEntityExtractor ReadableType = "Hierarchical Child Entity Extractor"
	// ReadableTypeHierarchicalEntityExtractor ...
	ReadableTypeHierarchicalEntityExtractor ReadableType = "Hierarchical Entity Extractor"
	// ReadableTypeIntentClassifier ...
	ReadableTypeIntentClassifier ReadableType = "Intent Classifier"
	// ReadableTypePrebuiltEntityExtractor ...
	ReadableTypePrebuiltEntityExtractor ReadableType = "Prebuilt Entity Extractor"
)

// PossibleReadableTypeValues returns an array of possible values for the ReadableType const type.
func PossibleReadableTypeValues() []ReadableType {
	return []ReadableType{ReadableTypeClosedListEntityExtractor, ReadableTypeCompositeEntityExtractor, ReadableTypeEntityExtractor, ReadableTypeHierarchicalChildEntityExtractor, ReadableTypeHierarchicalEntityExtractor, ReadableTypeIntentClassifier, ReadableTypePrebuiltEntityExtractor}
}

// ReadableType1 enumerates the values for readable type 1.
type ReadableType1 string

const (
	// ReadableType1ClosedListEntityExtractor ...
	ReadableType1ClosedListEntityExtractor ReadableType1 = "Closed List Entity Extractor"
	// ReadableType1CompositeEntityExtractor ...
	ReadableType1CompositeEntityExtractor ReadableType1 = "Composite Entity Extractor"
	// ReadableType1EntityExtractor ...
	ReadableType1EntityExtractor ReadableType1 = "Entity Extractor"
	// ReadableType1HierarchicalChildEntityExtractor ...
	ReadableType1HierarchicalChildEntityExtractor ReadableType1 = "Hierarchical Child Entity Extractor"
	// ReadableType1HierarchicalEntityExtractor ...
	ReadableType1HierarchicalEntityExtractor ReadableType1 = "Hierarchical Entity Extractor"
	// ReadableType1IntentClassifier ...
	ReadableType1IntentClassifier ReadableType1 = "Intent Classifier"
	// ReadableType1PrebuiltEntityExtractor ...
	ReadableType1PrebuiltEntityExtractor ReadableType1 = "Prebuilt Entity Extractor"
)

// PossibleReadableType1Values returns an array of possible values for the ReadableType1 const type.
func PossibleReadableType1Values() []ReadableType1 {
	return []ReadableType1{ReadableType1ClosedListEntityExtractor, ReadableType1CompositeEntityExtractor, ReadableType1EntityExtractor, ReadableType1HierarchicalChildEntityExtractor, ReadableType1HierarchicalEntityExtractor, ReadableType1IntentClassifier, ReadableType1PrebuiltEntityExtractor}
}

// ReadableType2 enumerates the values for readable type 2.
type ReadableType2 string

const (
	// ReadableType2ClosedListEntityExtractor ...
	ReadableType2ClosedListEntityExtractor ReadableType2 = "Closed List Entity Extractor"
	// ReadableType2CompositeEntityExtractor ...
	ReadableType2CompositeEntityExtractor ReadableType2 = "Composite Entity Extractor"
	// ReadableType2EntityExtractor ...
	ReadableType2EntityExtractor ReadableType2 = "Entity Extractor"
	// ReadableType2HierarchicalChildEntityExtractor ...
	ReadableType2HierarchicalChildEntityExtractor ReadableType2 = "Hierarchical Child Entity Extractor"
	// ReadableType2HierarchicalEntityExtractor ...
	ReadableType2HierarchicalEntityExtractor ReadableType2 = "Hierarchical Entity Extractor"
	// ReadableType2IntentClassifier ...
	ReadableType2IntentClassifier ReadableType2 = "Intent Classifier"
	// ReadableType2PrebuiltEntityExtractor ...
	ReadableType2PrebuiltEntityExtractor ReadableType2 = "Prebuilt Entity Extractor"
)

// PossibleReadableType2Values returns an array of possible values for the ReadableType2 const type.
func PossibleReadableType2Values() []ReadableType2 {
	return []ReadableType2{ReadableType2ClosedListEntityExtractor, ReadableType2CompositeEntityExtractor, ReadableType2EntityExtractor, ReadableType2HierarchicalChildEntityExtractor, ReadableType2HierarchicalEntityExtractor, ReadableType2IntentClassifier, ReadableType2PrebuiltEntityExtractor}
}

// ReadableType3 enumerates the values for readable type 3.
type ReadableType3 string

const (
	// ReadableType3ClosedListEntityExtractor ...
	ReadableType3ClosedListEntityExtractor ReadableType3 = "Closed List Entity Extractor"
	// ReadableType3CompositeEntityExtractor ...
	ReadableType3CompositeEntityExtractor ReadableType3 = "Composite Entity Extractor"
	// ReadableType3EntityExtractor ...
	ReadableType3EntityExtractor ReadableType3 = "Entity Extractor"
	// ReadableType3HierarchicalChildEntityExtractor ...
	ReadableType3HierarchicalChildEntityExtractor ReadableType3 = "Hierarchical Child Entity Extractor"
	// ReadableType3HierarchicalEntityExtractor ...
	ReadableType3HierarchicalEntityExtractor ReadableType3 = "Hierarchical Entity Extractor"
	// ReadableType3IntentClassifier ...
	ReadableType3IntentClassifier ReadableType3 = "Intent Classifier"
	// ReadableType3PrebuiltEntityExtractor ...
	ReadableType3PrebuiltEntityExtractor ReadableType3 = "Prebuilt Entity Extractor"
)

// PossibleReadableType3Values returns an array of possible values for the ReadableType3 const type.
func PossibleReadableType3Values() []ReadableType3 {
	return []ReadableType3{ReadableType3ClosedListEntityExtractor, ReadableType3CompositeEntityExtractor, ReadableType3EntityExtractor, ReadableType3HierarchicalChildEntityExtractor, ReadableType3HierarchicalEntityExtractor, ReadableType3IntentClassifier, ReadableType3PrebuiltEntityExtractor}
}

// Status enumerates the values for status.
type Status string

const (
	// StatusFail ...
	StatusFail Status = "Fail"
	// StatusInProgress ...
	StatusInProgress Status = "InProgress"
	// StatusQueued ...
	StatusQueued Status = "Queued"
	// StatusSuccess ...
	StatusSuccess Status = "Success"
	// StatusUpToDate ...
	StatusUpToDate Status = "UpToDate"
)

// PossibleStatusValues returns an array of possible values for the Status const type.
func PossibleStatusValues() []Status {
	return []Status{StatusFail, StatusInProgress, StatusQueued, StatusSuccess, StatusUpToDate}
}

// Status1 enumerates the values for status 1.
type Status1 string

const (
	// Status1Fail ...
	Status1Fail Status1 = "Fail"
	// Status1InProgress ...
	Status1InProgress Status1 = "InProgress"
	// Status1Queued ...
	Status1Queued Status1 = "Queued"
	// Status1Success ...
	Status1Success Status1 = "Success"
	// Status1UpToDate ...
	Status1UpToDate Status1 = "UpToDate"
)

// PossibleStatus1Values returns an array of possible values for the Status1 const type.
func PossibleStatus1Values() []Status1 {
	return []Status1{Status1Fail, Status1InProgress, Status1Queued, Status1Success, Status1UpToDate}
}

// TrainingStatus enumerates the values for training status.
type TrainingStatus string

const (
	// InProgress ...
	InProgress TrainingStatus = "InProgress"
	// NeedsTraining ...
	NeedsTraining TrainingStatus = "NeedsTraining"
	// Trained ...
	Trained TrainingStatus = "Trained"
)

// PossibleTrainingStatusValues returns an array of possible values for the TrainingStatus const type.
func PossibleTrainingStatusValues() []TrainingStatus {
	return []TrainingStatus{InProgress, NeedsTraining, Trained}
}

// ApplicationCreateObject properties for creating a new LUIS Application
type ApplicationCreateObject struct {
	// Culture - The culture for the new application. It is the language that your app understands and speaks. E.g.: "en-us". Note: the culture cannot be changed after the app is created.
	Culture *string `json:"culture,omitempty"`
	// Domain - The domain for the new application. Optional. E.g.: Comics.
	Domain *string `json:"domain,omitempty"`
	// Description - Description of the new application. Optional.
	Description *string `json:"description,omitempty"`
	// InitialVersionID - The initial version ID. Optional. Default value is: "0.1"
	InitialVersionID *string `json:"initialVersionId,omitempty"`
	// UsageScenario - Defines the scenario for the new application. Optional. E.g.: IoT.
	UsageScenario *string `json:"usageScenario,omitempty"`
	// Name - The name for the new application.
	Name *string `json:"name,omitempty"`
}

// ApplicationInfoResponse response containing the Application Info.
type ApplicationInfoResponse struct {
	autorest.Response `json:"-"`
	// ID - The ID (GUID) of the application.
	ID *uuid.UUID `json:"id,omitempty"`
	// Name - The name of the application.
	Name *string `json:"name,omitempty"`
	// Description - The description of the application.
	Description *string `json:"description,omitempty"`
	// Culture - The culture of the application. E.g.: en-us.
	Culture *string `json:"culture,omitempty"`
	// UsageScenario - Defines the scenario for the new application. Optional. E.g.: IoT.
	UsageScenario *string `json:"usageScenario,omitempty"`
	// Domain - The domain for the new application. Optional. E.g.: Comics.
	Domain *string `json:"domain,omitempty"`
	// VersionsCount - Amount of model versions within the application.
	VersionsCount *int32 `json:"versionsCount,omitempty"`
	// CreatedDateTime - The version's creation timestamp.
	CreatedDateTime *string `json:"createdDateTime,omitempty"`
	// Endpoints - The Runtime endpoint URL for this model version.
	Endpoints interface{} `json:"endpoints,omitempty"`
	// EndpointHitsCount - Number of calls made to this endpoint.
	EndpointHitsCount *int32 `json:"endpointHitsCount,omitempty"`
	// ActiveVersion - The version ID currently marked as active.
	ActiveVersion *string `json:"activeVersion,omitempty"`
}

// ApplicationPublishObject object model for publishing a specific application version.
type ApplicationPublishObject struct {
	// VersionID - The version ID to publish.
	VersionID *string `json:"versionId,omitempty"`
	// IsStaging - Indicates if the staging slot should be used, instead of the Production one.
	IsStaging *bool `json:"isStaging,omitempty"`
	// Region - The target region that the application is published to.
	Region *string `json:"region,omitempty"`
}

// ApplicationSettings the application settings.
type ApplicationSettings struct {
	autorest.Response `json:"-"`
	// ID - The application ID.
	ID *uuid.UUID `json:"id,omitempty"`
	// IsPublic - Setting your application as public allows other people to use your application's endpoint using their own keys.
	IsPublic *bool `json:"public,omitempty"`
}

// ApplicationSettingUpdateObject object model for updating an application's settings.
type ApplicationSettingUpdateObject struct {
	// Public - Setting your application as public allows other people to use your application's endpoint using their own keys.
	Public *bool `json:"public,omitempty"`
}

// ApplicationUpdateObject object model for updating the name or description of an application.
type ApplicationUpdateObject struct {
	// Name - The application's new name.
	Name *string `json:"name,omitempty"`
	// Description - The application's new description.
	Description *string `json:"description,omitempty"`
}

// AvailableCulture available culture for using in a new application.
type AvailableCulture struct {
	// Name - The language name.
	Name *string `json:"name,omitempty"`
	// Code - The ISO value for the language.
	Code *string `json:"code,omitempty"`
}

// AvailablePrebuiltEntityModel available Prebuilt entity model for using in an application.
type AvailablePrebuiltEntityModel struct {
	// Name - The entity name.
	Name *string `json:"name,omitempty"`
	// Description - The entity description and usage information.
	Description *string `json:"description,omitempty"`
	// Examples - Usage examples.
	Examples *string `json:"examples,omitempty"`
}

// BatchLabelExample response when adding a batch of labeled examples.
type BatchLabelExample struct {
	Value    *LabelExampleResponse `json:"value,omitempty"`
	HasError *bool                 `json:"hasError,omitempty"`
	Error    *OperationStatus      `json:"error,omitempty"`
}

// ChildEntity the base child entity type.
type ChildEntity struct {
	// ID - The ID (GUID) belonging to a child entity.
	ID *uuid.UUID `json:"id,omitempty"`
	// Name - The name of a child entity.
	Name *string `json:"name,omitempty"`
}

// ClosedList exported Model - A Closed List.
type ClosedList struct {
	// Name - Name of the closed list feature.
	Name *string `json:"name,omitempty"`
	// SubLists - Sublists for the feature.
	SubLists *[]SubClosedList `json:"subLists,omitempty"`
}

// ClosedListEntityExtractor closed List Entity Extractor.
type ClosedListEntityExtractor struct {
	autorest.Response `json:"-"`
	// SubLists - List of sub-lists.
	SubLists *[]SubClosedListResponse `json:"subLists,omitempty"`
	// ID - The ID of the Entity Model.
	ID *uuid.UUID `json:"id,omitempty"`
	// Name - Name of the Entity Model.
	Name *string `json:"name,omitempty"`
	// TypeID - The type ID of the Entity Model.
	TypeID *int32 `json:"typeId,omitempty"`
	// ReadableType - Possible values include: 'ReadableTypeEntityExtractor', 'ReadableTypeHierarchicalEntityExtractor', 'ReadableTypeHierarchicalChildEntityExtractor', 'ReadableTypeCompositeEntityExtractor', 'ReadableTypeClosedListEntityExtractor', 'ReadableTypePrebuiltEntityExtractor', 'ReadableTypeIntentClassifier'
	ReadableType ReadableType `json:"readableType,omitempty"`
}

// ClosedListModelCreateObject object model for creating a closed list.
type ClosedListModelCreateObject struct {
	// SubLists - Sublists for the feature.
	SubLists *[]WordListObject `json:"subLists,omitempty"`
	// Name - Name of the closed list feature.
	Name *string `json:"name,omitempty"`
}

// ClosedListModelPatchObject object model for adding a batch of sublists to an existing closedlist.
type ClosedListModelPatchObject struct {
	// SubLists - Sublists to add.
	SubLists *[]WordListObject `json:"subLists,omitempty"`
}

// ClosedListModelUpdateObject object model for updating a closed list.
type ClosedListModelUpdateObject struct {
	// SubLists - The new sublists for the feature.
	SubLists *[]WordListObject `json:"subLists,omitempty"`
	// Name - The new name of the closed list feature.
	Name *string `json:"name,omitempty"`
}

// CollaboratorsArray ...
type CollaboratorsArray struct {
	// Emails - The email address of the users.
	Emails *[]string `json:"emails,omitempty"`
}

// CompositeChildModelCreateObject ...
type CompositeChildModelCreateObject struct {
	Name *string `json:"name,omitempty"`
}

// CompositeEntityExtractor a Composite Entity Extractor.
type CompositeEntityExtractor struct {
	autorest.Response `json:"-"`
	// Children - List of child entities.
	Children *[]ChildEntity `json:"children,omitempty"`
	// ID - The ID of the Entity Model.
	ID *uuid.UUID `json:"id,omitempty"`
	// Name - Name of the Entity Model.
	Name *string `json:"name,omitempty"`
	// TypeID - The type ID of the Entity Model.
	TypeID *int32 `json:"typeId,omitempty"`
	// ReadableType - Possible values include: 'ReadableTypeEntityExtractor', 'ReadableTypeHierarchicalEntityExtractor', 'ReadableTypeHierarchicalChildEntityExtractor', 'ReadableTypeCompositeEntityExtractor', 'ReadableTypeClosedListEntityExtractor', 'ReadableTypePrebuiltEntityExtractor', 'ReadableTypeIntentClassifier'
	ReadableType ReadableType `json:"readableType,omitempty"`
}

// CompositeEntityModel a composite entity.
type CompositeEntityModel struct {
	// Children - Child entities.
	Children *[]string `json:"children,omitempty"`
	// Name - Entity name.
	Name *string `json:"name,omitempty"`
}

// CustomPrebuiltModel a Custom Prebuilt model.
type CustomPrebuiltModel struct {
	// ID - The ID of the Entity Model.
	ID *uuid.UUID `json:"id,omitempty"`
	// Name - Name of the Entity Model.
	Name *string `json:"name,omitempty"`
	// TypeID - The type ID of the Entity Model.
	TypeID *int32 `json:"typeId,omitempty"`
	// ReadableType - Possible values include: 'ReadableType3EntityExtractor', 'ReadableType3HierarchicalEntityExtractor', 'ReadableType3HierarchicalChildEntityExtractor', 'ReadableType3CompositeEntityExtractor', 'ReadableType3ClosedListEntityExtractor', 'ReadableType3PrebuiltEntityExtractor', 'ReadableType3IntentClassifier'
	ReadableType ReadableType3 `json:"readableType,omitempty"`
	// CustomPrebuiltDomainName - The domain name.
	CustomPrebuiltDomainName *string `json:"customPrebuiltDomainName,omitempty"`
	// CustomPrebuiltModelName - The intent name or entity name.
	CustomPrebuiltModelName *string `json:"customPrebuiltModelName,omitempty"`
}

// EndpointInfo the base class "ProductionOrStagingEndpointInfo" inherits from.
type EndpointInfo struct {
	// VersionID - The version ID to publish.
	VersionID *string `json:"versionId,omitempty"`
	// IsStaging - Indicates if the staging slot should be used, instead of the Production one.
	IsStaging *bool `json:"isStaging,omitempty"`
	// EndpointURL - The Runtime endpoint URL for this model version.
	EndpointURL *string `json:"endpointUrl,omitempty"`
	// Region - The target region that the application is published to.
	Region *string `json:"region,omitempty"`
	// AssignedEndpointKey - The endpoint key.
	AssignedEndpointKey *string `json:"assignedEndpointKey,omitempty"`
	// EndpointRegion - The endpoint's region.
	EndpointRegion *string `json:"endpointRegion,omitempty"`
	// PublishedDateTime - Timestamp when was last published.
	PublishedDateTime *string `json:"publishedDateTime,omitempty"`
}

// EnqueueTrainingResponse response model when requesting to train the model.
type EnqueueTrainingResponse struct {
	autorest.Response `json:"-"`
	// StatusID - The train request status ID.
	StatusID *int32 `json:"statusId,omitempty"`
	// Status - Possible values include: 'StatusQueued', 'StatusInProgress', 'StatusUpToDate', 'StatusFail', 'StatusSuccess'
	Status Status `json:"status,omitempty"`
}

// EntitiesSuggestionExample predicted/suggested entity.
type EntitiesSuggestionExample struct {
	// Text - The utterance. E.g.: what's the weather like in seattle?
	Text *string `json:"text,omitempty"`
	// TokenizedText - The utterance tokenized.
	TokenizedText *[]string `json:"tokenizedText,omitempty"`
	// IntentPredictions - Predicted/suggested intents.
	IntentPredictions *[]IntentPrediction `json:"intentPredictions,omitempty"`
	// EntityPredictions - Predicted/suggested entities.
	EntityPredictions *[]EntityPrediction `json:"entityPredictions,omitempty"`
}

// EntityExtractor entity Extractor.
type EntityExtractor struct {
	autorest.Response `json:"-"`
	// CustomPrebuiltDomainName - The domain name.
	CustomPrebuiltDomainName *string `json:"customPrebuiltDomainName,omitempty"`
	// CustomPrebuiltModelName - The intent name or entity name.
	CustomPrebuiltModelName *string `json:"customPrebuiltModelName,omitempty"`
	// ID - The ID of the Entity Model.
	ID *uuid.UUID `json:"id,omitempty"`
	// Name - Name of the Entity Model.
	Name *string `json:"name,omitempty"`
	// TypeID - The type ID of the Entity Model.
	TypeID *int32 `json:"typeId,omitempty"`
	// ReadableType - Possible values include: 'ReadableTypeEntityExtractor', 'ReadableTypeHierarchicalEntityExtractor', 'ReadableTypeHierarchicalChildEntityExtractor', 'ReadableTypeCompositeEntityExtractor', 'ReadableTypeClosedListEntityExtractor', 'ReadableTypePrebuiltEntityExtractor', 'ReadableTypeIntentClassifier'
	ReadableType ReadableType `json:"readableType,omitempty"`
}

// EntityLabel defines the entity type and position of the extracted entity within the example.
type EntityLabel struct {
	// EntityName - The entity type.
	EntityName *string `json:"entityName,omitempty"`
	// StartTokenIndex - The index within the utterance where the extracted entity starts.
	StartTokenIndex *int32 `json:"startTokenIndex,omitempty"`
	// EndTokenIndex - The index within the utterance where the extracted entity ends.
	EndTokenIndex *int32 `json:"endTokenIndex,omitempty"`
}

// EntityLabelObject defines the entity type and position of the extracted entity within the example.
type EntityLabelObject struct {
	// EntityName - The entity type.
	EntityName *string `json:"entityName,omitempty"`
	// StartCharIndex - The index within the utterance where the extracted entity starts.
	StartCharIndex *int32 `json:"startCharIndex,omitempty"`
	// EndCharIndex - The index within the utterance where the extracted entity ends.
	EndCharIndex *int32 `json:"endCharIndex,omitempty"`
}

// EntityPrediction a suggested entity.
type EntityPrediction struct {
	// EntityName - The entity's name
	EntityName *string `json:"entityName,omitempty"`
	// StartTokenIndex - The index within the utterance where the extracted entity starts.
	StartTokenIndex *int32 `json:"startTokenIndex,omitempty"`
	// EndTokenIndex - The index within the utterance where the extracted entity ends.
	EndTokenIndex *int32 `json:"endTokenIndex,omitempty"`
	// Phrase - The actual token(s) that comprise the entity.
	Phrase *string `json:"phrase,omitempty"`
}

// ErrorResponse error response when invoking an operation on the API.
type ErrorResponse struct {
	// AdditionalProperties - Unmatched properties from the message are deserialized this collection
	AdditionalProperties map[string]interface{} `json:""`
	ErrorType            *string                `json:"errorType,omitempty"`
}

// MarshalJSON is the custom marshaler for ErrorResponse.
func (er ErrorResponse) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if er.ErrorType != nil {
		objectMap["errorType"] = er.ErrorType
	}
	for k, v := range er.AdditionalProperties {
		objectMap[k] = v
	}
	return json.Marshal(objectMap)
}

// ExampleLabelObject a labeled example.
type ExampleLabelObject struct {
	// Text - The sample's utterance.
	Text *string `json:"text,omitempty"`
	// EntityLabels - The idenfied entities within the utterance.
	EntityLabels *[]EntityLabelObject `json:"entityLabels,omitempty"`
	// IntentName - The idenfitied intent representing the utterance.
	IntentName *string `json:"intentName,omitempty"`
}

// FeatureInfoObject the base class Features-related response objects inherit from.
type FeatureInfoObject struct {
	// ID - A six-digit ID used for Features.
	ID *int32 `json:"id,omitempty"`
	// Name - The name of the Feature.
	Name *string `json:"name,omitempty"`
	// IsActive - Indicates if the feature is enabled.
	IsActive *bool `json:"isActive,omitempty"`
}

// FeaturesResponseObject model Features, including Patterns and Phraselists.
type FeaturesResponseObject struct {
	autorest.Response  `json:"-"`
	PhraselistFeatures *[]PhraseListFeatureInfo `json:"phraselistFeatures,omitempty"`
	PatternFeatures    *[]PatternFeatureInfo    `json:"patternFeatures,omitempty"`
}

// HierarchicalChildEntity a Hierarchical Child Entity.
type HierarchicalChildEntity struct {
	autorest.Response `json:"-"`
	// TypeID - The type ID of the Entity Model.
	TypeID *int32 `json:"typeId,omitempty"`
	// ReadableType - Possible values include: 'ReadableType2EntityExtractor', 'ReadableType2HierarchicalEntityExtractor', 'ReadableType2HierarchicalChildEntityExtractor', 'ReadableType2CompositeEntityExtractor', 'ReadableType2ClosedListEntityExtractor', 'ReadableType2PrebuiltEntityExtractor', 'ReadableType2IntentClassifier'
	ReadableType ReadableType2 `json:"readableType,omitempty"`
	// ID - The ID (GUID) belonging to a child entity.
	ID *uuid.UUID `json:"id,omitempty"`
	// Name - The name of a child entity.
	Name *string `json:"name,omitempty"`
}

// HierarchicalChildModelCreateObject ...
type HierarchicalChildModelCreateObject struct {
	Name *string `json:"name,omitempty"`
}

// HierarchicalChildModelUpdateObject ...
type HierarchicalChildModelUpdateObject struct {
	Name *string `json:"name,omitempty"`
}

// HierarchicalEntityExtractor hierarchical Entity Extractor.
type HierarchicalEntityExtractor struct {
	autorest.Response `json:"-"`
	// Children - List of child entities.
	Children *[]ChildEntity `json:"children,omitempty"`
	// ID - The ID of the Entity Model.
	ID *uuid.UUID `json:"id,omitempty"`
	// Name - Name of the Entity Model.
	Name *string `json:"name,omitempty"`
	// TypeID - The type ID of the Entity Model.
	TypeID *int32 `json:"typeId,omitempty"`
	// ReadableType - Possible values include: 'ReadableTypeEntityExtractor', 'ReadableTypeHierarchicalEntityExtractor', 'ReadableTypeHierarchicalChildEntityExtractor', 'ReadableTypeCompositeEntityExtractor', 'ReadableTypeClosedListEntityExtractor', 'ReadableTypePrebuiltEntityExtractor', 'ReadableTypeIntentClassifier'
	ReadableType ReadableType `json:"readableType,omitempty"`
}

// HierarchicalEntityModel a Hierarchical Entity Extractor.
type HierarchicalEntityModel struct {
	// Children - Child entities.
	Children *[]string `json:"children,omitempty"`
	// Name - Entity name.
	Name *string `json:"name,omitempty"`
}

// HierarchicalModel ...
type HierarchicalModel struct {
	Name     *string   `json:"name,omitempty"`
	Children *[]string `json:"children,omitempty"`
}

// Int32 ...
type Int32 struct {
	autorest.Response `json:"-"`
	Value             *int32 `json:"value,omitempty"`
}

// IntentClassifier intent Classifier.
type IntentClassifier struct {
	autorest.Response `json:"-"`
	// CustomPrebuiltDomainName - The domain name.
	CustomPrebuiltDomainName *string `json:"customPrebuiltDomainName,omitempty"`
	// CustomPrebuiltModelName - The intent name or entity name.
	CustomPrebuiltModelName *string `json:"customPrebuiltModelName,omitempty"`
	// ID - The ID of the Entity Model.
	ID *uuid.UUID `json:"id,omitempty"`
	// Name - Name of the Entity Model.
	Name *string `json:"name,omitempty"`
	// TypeID - The type ID of the Entity Model.
	TypeID *int32 `json:"typeId,omitempty"`
	// ReadableType - Possible values include: 'ReadableTypeEntityExtractor', 'ReadableTypeHierarchicalEntityExtractor', 'ReadableTypeHierarchicalChildEntityExtractor', 'ReadableTypeCompositeEntityExtractor', 'ReadableTypeClosedListEntityExtractor', 'ReadableTypePrebuiltEntityExtractor', 'ReadableTypeIntentClassifier'
	ReadableType ReadableType `json:"readableType,omitempty"`
}

// IntentPrediction a suggested intent.
type IntentPrediction struct {
	// Name - The intent's name
	Name *string `json:"name,omitempty"`
	// Score - The intent's score, based on the prediction model.
	Score *float64 `json:"score,omitempty"`
}

// IntentsSuggestionExample predicted/suggested intent.
type IntentsSuggestionExample struct {
	// Text - The utterance. E.g.: what's the weather like in seattle?
	Text *string `json:"text,omitempty"`
	// TokenizedText - The utterance tokenized.
	TokenizedText *[]string `json:"tokenizedText,omitempty"`
	// IntentPredictions - Predicted/suggested intents.
	IntentPredictions *[]IntentPrediction `json:"intentPredictions,omitempty"`
	// EntityPredictions - Predicted/suggested entities.
	EntityPredictions *[]EntityPrediction `json:"entityPredictions,omitempty"`
}

// JSONEntity exported Model - Extracted Entity from utterance.
type JSONEntity struct {
	// StartPos - The index within the utterance where the extracted entity starts.
	StartPos *int32 `json:"startPos,omitempty"`
	// EndPos - The index within the utterance where the extracted entity ends.
	EndPos *int32 `json:"endPos,omitempty"`
	// Entity - The entity name.
	Entity *string `json:"entity,omitempty"`
}

// JSONModelFeature exported Model - Phraselist Model Feature.
type JSONModelFeature struct {
	// Activated - Indicates if the feature is enabled.
	Activated *bool `json:"activated,omitempty"`
	// Name - The Phraselist name.
	Name *string `json:"name,omitempty"`
	// Words - List of comma-separated phrases that represent the Phraselist.
	Words *string `json:"words,omitempty"`
	// Mode - An exchangeable phrase list feature are serves as single feature to the LUIS underlying training algorithm. It is used as a lexicon lookup feature where its value is 1 if the lexicon contains a given word or 0 if it doesn’t. Think of an exchangeable as a synonyms list. A non-exchangeable phrase list feature has all the phrases in the list serve as separate features to the underlying training algorithm. So, if you your phrase list feature contains 5 phrases, they will be mapped to 5 separate features. You can think of the non-exchangeable phrase list feature as an additional bag of words that you are willing to add to LUIS existing vocabulary features. Think of a non-exchangeable as set of different words. Default value is true.
	Mode *bool `json:"mode,omitempty"`
}

// JSONRegexFeature exported Model - A Pattern feature.
type JSONRegexFeature struct {
	// Pattern - The Regular Expression to match.
	Pattern *string `json:"pattern,omitempty"`
	// Activated - Indicates if the Pattern feature is enabled.
	Activated *bool `json:"activated,omitempty"`
	// Name - Name of the feature.
	Name *string `json:"name,omitempty"`
}

// JSONUtterance exported Model - Utterance that was used to train the model.
type JSONUtterance struct {
	// Text - The utterance.
	Text *string `json:"text,omitempty"`
	// Intent - The matched intent.
	Intent *string `json:"intent,omitempty"`
	// Entities - The matched entities.
	Entities *[]JSONEntity `json:"entities,omitempty"`
}

// LabeledUtterance a prediction and label pair of an example.
type LabeledUtterance struct {
	// ID - ID of Labeled Utterance.
	ID *int32 `json:"id,omitempty"`
	// Text - The utterance. E.g.: what's the weather like in seattle?
	Text *string `json:"text,omitempty"`
	// TokenizedText - The utterance tokenized.
	TokenizedText *[]string `json:"tokenizedText,omitempty"`
	// IntentLabel - The intent matching the example.
	IntentLabel *string `json:"intentLabel,omitempty"`
	// EntityLabels - The entities matching the example.
	EntityLabels *[]EntityLabel `json:"entityLabels,omitempty"`
	// IntentPredictions - List of suggested intents.
	IntentPredictions *[]IntentPrediction `json:"intentPredictions,omitempty"`
	// EntityPredictions - List of suggested entities.
	EntityPredictions *[]EntityPrediction `json:"entityPredictions,omitempty"`
}

// LabelExampleResponse response when adding a labeled example.
type LabelExampleResponse struct {
	autorest.Response `json:"-"`
	// UtteranceText - The sample's utterance.
	UtteranceText *string `json:"UtteranceText,omitempty"`
	// ExampleID - The newly created sample ID.
	ExampleID *int32 `json:"ExampleId,omitempty"`
}

// ListApplicationInfoResponse ...
type ListApplicationInfoResponse struct {
	autorest.Response `json:"-"`
	Value             *[]ApplicationInfoResponse `json:"value,omitempty"`
}

// ListAvailableCulture ...
type ListAvailableCulture struct {
	autorest.Response `json:"-"`
	Value             *[]AvailableCulture `json:"value,omitempty"`
}

// ListAvailablePrebuiltEntityModel ...
type ListAvailablePrebuiltEntityModel struct {
	autorest.Response `json:"-"`
	Value             *[]AvailablePrebuiltEntityModel `json:"value,omitempty"`
}

// ListBatchLabelExample ...
type ListBatchLabelExample struct {
	autorest.Response `json:"-"`
	Value             *[]BatchLabelExample `json:"value,omitempty"`
}

// ListClosedListEntityExtractor ...
type ListClosedListEntityExtractor struct {
	autorest.Response `json:"-"`
	Value             *[]ClosedListEntityExtractor `json:"value,omitempty"`
}

// ListCompositeEntityExtractor ...
type ListCompositeEntityExtractor struct {
	autorest.Response `json:"-"`
	Value             *[]CompositeEntityExtractor `json:"value,omitempty"`
}

// ListCustomPrebuiltModel ...
type ListCustomPrebuiltModel struct {
	autorest.Response `json:"-"`
	Value             *[]CustomPrebuiltModel `json:"value,omitempty"`
}

// ListEntitiesSuggestionExample ...
type ListEntitiesSuggestionExample struct {
	autorest.Response `json:"-"`
	Value             *[]EntitiesSuggestionExample `json:"value,omitempty"`
}

// ListEntityExtractor ...
type ListEntityExtractor struct {
	autorest.Response `json:"-"`
	Value             *[]EntityExtractor `json:"value,omitempty"`
}

// ListHierarchicalEntityExtractor ...
type ListHierarchicalEntityExtractor struct {
	autorest.Response `json:"-"`
	Value             *[]HierarchicalEntityExtractor `json:"value,omitempty"`
}

// ListIntentClassifier ...
type ListIntentClassifier struct {
	autorest.Response `json:"-"`
	Value             *[]IntentClassifier `json:"value,omitempty"`
}

// ListIntentsSuggestionExample ...
type ListIntentsSuggestionExample struct {
	autorest.Response `json:"-"`
	Value             *[]IntentsSuggestionExample `json:"value,omitempty"`
}

// ListLabeledUtterance ...
type ListLabeledUtterance struct {
	autorest.Response `json:"-"`
	Value             *[]LabeledUtterance `json:"value,omitempty"`
}

// ListModelInfoResponse ...
type ListModelInfoResponse struct {
	autorest.Response `json:"-"`
	Value             *[]ModelInfoResponse `json:"value,omitempty"`
}

// ListModelTrainingInfo ...
type ListModelTrainingInfo struct {
	autorest.Response `json:"-"`
	Value             *[]ModelTrainingInfo `json:"value,omitempty"`
}

// ListPhraseListFeatureInfo ...
type ListPhraseListFeatureInfo struct {
	autorest.Response `json:"-"`
	Value             *[]PhraseListFeatureInfo `json:"value,omitempty"`
}

// ListPrebuiltDomain ...
type ListPrebuiltDomain struct {
	autorest.Response `json:"-"`
	Value             *[]PrebuiltDomain `json:"value,omitempty"`
}

// ListPrebuiltEntityExtractor ...
type ListPrebuiltEntityExtractor struct {
	autorest.Response `json:"-"`
	Value             *[]PrebuiltEntityExtractor `json:"value,omitempty"`
}

// ListString ...
type ListString struct {
	autorest.Response `json:"-"`
	Value             *[]string `json:"value,omitempty"`
}

// ListUUID ...
type ListUUID struct {
	autorest.Response `json:"-"`
	Value             *[]uuid.UUID `json:"value,omitempty"`
}

// ListVersionInfo ...
type ListVersionInfo struct {
	autorest.Response `json:"-"`
	Value             *[]VersionInfo `json:"value,omitempty"`
}

// LuisApp exported Model - An exported LUIS Application.
type LuisApp struct {
	autorest.Response `json:"-"`
	// AdditionalProperties - Unmatched properties from the message are deserialized this collection
	AdditionalProperties map[string]interface{} `json:""`
	// Name - The name of the application.
	Name *string `json:"name,omitempty"`
	// VersionID - The version ID of the application that was exported.
	VersionID *string `json:"versionId,omitempty"`
	// Desc - The description of the application.
	Desc *string `json:"desc,omitempty"`
	// Culture - The culture of the application. E.g.: en-us.
	Culture *string `json:"culture,omitempty"`
	// Intents - List of intents.
	Intents *[]HierarchicalModel `json:"intents,omitempty"`
	// Entities - List of entities.
	Entities *[]HierarchicalModel `json:"entities,omitempty"`
	// BingEntities - List of prebuilt intents.
	BingEntities *[]string `json:"bing_entities,omitempty"`
	// ClosedLists - List of closed lists.
	ClosedLists *[]ClosedList `json:"closedLists,omitempty"`
	// Composites - List of composite entities.
	Composites *[]HierarchicalModel `json:"composites,omitempty"`
	// RegexFeatures - List of pattern features.
	RegexFeatures *[]JSONRegexFeature `json:"regex_features,omitempty"`
	// ModelFeatures - List of model features.
	ModelFeatures *[]JSONModelFeature `json:"model_features,omitempty"`
	// Utterances - List of sample utterances.
	Utterances *[]JSONUtterance `json:"utterances,omitempty"`
}

// MarshalJSON is the custom marshaler for LuisApp.
func (la LuisApp) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if la.Name != nil {
		objectMap["name"] = la.Name
	}
	if la.VersionID != nil {
		objectMap["versionId"] = la.VersionID
	}
	if la.Desc != nil {
		objectMap["desc"] = la.Desc
	}
	if la.Culture != nil {
		objectMap["culture"] = la.Culture
	}
	if la.Intents != nil {
		objectMap["intents"] = la.Intents
	}
	if la.Entities != nil {
		objectMap["entities"] = la.Entities
	}
	if la.BingEntities != nil {
		objectMap["bing_entities"] = la.BingEntities
	}
	if la.ClosedLists != nil {
		objectMap["closedLists"] = la.ClosedLists
	}
	if la.Composites != nil {
		objectMap["composites"] = la.Composites
	}
	if la.RegexFeatures != nil {
		objectMap["regex_features"] = la.RegexFeatures
	}
	if la.ModelFeatures != nil {
		objectMap["model_features"] = la.ModelFeatures
	}
	if la.Utterances != nil {
		objectMap["utterances"] = la.Utterances
	}
	for k, v := range la.AdditionalProperties {
		objectMap[k] = v
	}
	return json.Marshal(objectMap)
}

// ModelCreateObject object model for creating a new entity extractor.
type ModelCreateObject struct {
	// Name - Name of the new entity extractor.
	Name *string `json:"name,omitempty"`
}

// ModelInfo base type used in entity types.
type ModelInfo struct {
	// ID - The ID of the Entity Model.
	ID *uuid.UUID `json:"id,omitempty"`
	// Name - Name of the Entity Model.
	Name *string `json:"name,omitempty"`
	// TypeID - The type ID of the Entity Model.
	TypeID *int32 `json:"typeId,omitempty"`
	// ReadableType - Possible values include: 'ReadableTypeEntityExtractor', 'ReadableTypeHierarchicalEntityExtractor', 'ReadableTypeHierarchicalChildEntityExtractor', 'ReadableTypeCompositeEntityExtractor', 'ReadableTypeClosedListEntityExtractor', 'ReadableTypePrebuiltEntityExtractor', 'ReadableTypeIntentClassifier'
	ReadableType ReadableType `json:"readableType,omitempty"`
}

// ModelInfoResponse an application model info.
type ModelInfoResponse struct {
	// Children - List of child entities.
	Children *[]ChildEntity `json:"children,omitempty"`
	// SubLists - List of sub-lists.
	SubLists *[]SubClosedListResponse `json:"subLists,omitempty"`
	// CustomPrebuiltDomainName - The domain name.
	CustomPrebuiltDomainName *string `json:"customPrebuiltDomainName,omitempty"`
	// CustomPrebuiltModelName - The intent name or entity name.
	CustomPrebuiltModelName *string `json:"customPrebuiltModelName,omitempty"`
	// ID - The ID of the Entity Model.
	ID *uuid.UUID `json:"id,omitempty"`
	// Name - Name of the Entity Model.
	Name *string `json:"name,omitempty"`
	// TypeID - The type ID of the Entity Model.
	TypeID *int32 `json:"typeId,omitempty"`
	// ReadableType - Possible values include: 'ReadableType1EntityExtractor', 'ReadableType1HierarchicalEntityExtractor', 'ReadableType1HierarchicalChildEntityExtractor', 'ReadableType1CompositeEntityExtractor', 'ReadableType1ClosedListEntityExtractor', 'ReadableType1PrebuiltEntityExtractor', 'ReadableType1IntentClassifier'
	ReadableType ReadableType1 `json:"readableType,omitempty"`
}

// ModelTrainingDetails model Training Details.
type ModelTrainingDetails struct {
	// StatusID - The train request status ID.
	StatusID *int32 `json:"statusId,omitempty"`
	// Status - Possible values include: 'Status1Queued', 'Status1InProgress', 'Status1UpToDate', 'Status1Fail', 'Status1Success'
	Status Status1 `json:"status,omitempty"`
	// ExampleCount - The count of examples used to train the model.
	ExampleCount *int32 `json:"exampleCount,omitempty"`
	// TrainingDateTime - When the model was trained.
	TrainingDateTime *date.Time `json:"trainingDateTime,omitempty"`
	// FailureReason - Reason for the training failure.
	FailureReason *string `json:"failureReason,omitempty"`
}

// ModelTrainingInfo model Training Info.
type ModelTrainingInfo struct {
	// ModelID - The ID (GUID) of the model.
	ModelID *uuid.UUID            `json:"modelId,omitempty"`
	Details *ModelTrainingDetails `json:"details,omitempty"`
}

// ModelUpdateObject object model for updating an intent classifier.
type ModelUpdateObject struct {
	// Name - The entity's new name.
	Name *string `json:"name,omitempty"`
}

// OperationError operation error details when invoking an operation on the API.
type OperationError struct {
	Code    *string `json:"code,omitempty"`
	Message *string `json:"message,omitempty"`
}

// OperationStatus response of an Operation status.
type OperationStatus struct {
	autorest.Response `json:"-"`
	// Code - Status Code. Possible values include: 'Failed', 'FAILED', 'Success'
	Code OperationStatusType `json:"code,omitempty"`
	// Message - Status details.
	Message *string `json:"message,omitempty"`
}

// PatternCreateObject object model for creating a Pattern feature.
type PatternCreateObject struct {
	// Pattern - The Regular Expression to match.
	Pattern *string `json:"pattern,omitempty"`
	// Name - Name of the feature.
	Name *string `json:"name,omitempty"`
}

// PatternFeatureInfo pattern feature.
type PatternFeatureInfo struct {
	// Pattern - The Regular Expression to match.
	Pattern *string `json:"pattern,omitempty"`
	// ID - A six-digit ID used for Features.
	ID *int32 `json:"id,omitempty"`
	// Name - The name of the Feature.
	Name *string `json:"name,omitempty"`
	// IsActive - Indicates if the feature is enabled.
	IsActive *bool `json:"isActive,omitempty"`
}

// PatternUpdateObject object model for updating an existing Pattern feature.
type PatternUpdateObject struct {
	// Pattern - The Regular Expression to match.
	Pattern *string `json:"pattern,omitempty"`
	// Name - Name of the feature.
	Name *string `json:"name,omitempty"`
	// IsActive - Indicates if the Pattern feature is enabled.
	IsActive *bool `json:"isActive,omitempty"`
}

// PersonalAssistantsResponse response containing user's endpoint keys and the endpoint URLs of the prebuilt
// Cortana applications.
type PersonalAssistantsResponse struct {
	autorest.Response `json:"-"`
	EndpointKeys      *[]uuid.UUID       `json:"endpointKeys,omitempty"`
	EndpointUrls      map[string]*string `json:"endpointUrls"`
}

// MarshalJSON is the custom marshaler for PersonalAssistantsResponse.
func (par PersonalAssistantsResponse) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if par.EndpointKeys != nil {
		objectMap["endpointKeys"] = par.EndpointKeys
	}
	if par.EndpointUrls != nil {
		objectMap["endpointUrls"] = par.EndpointUrls
	}
	return json.Marshal(objectMap)
}

// PhraselistCreateObject object model for creating a phraselist model.
type PhraselistCreateObject struct {
	// Phrases - List of comma-separated phrases that represent the Phraselist.
	Phrases *string `json:"phrases,omitempty"`
	// Name - The Phraselist name.
	Name *string `json:"name,omitempty"`
	// IsExchangeable - An exchangeable phrase list feature are serves as single feature to the LUIS underlying training algorithm. It is used as a lexicon lookup feature where its value is 1 if the lexicon contains a given word or 0 if it doesn’t. Think of an exchangeable as a synonyms list. A non-exchangeable phrase list feature has all the phrases in the list serve as separate features to the underlying training algorithm. So, if you your phrase list feature contains 5 phrases, they will be mapped to 5 separate features. You can think of the non-exchangeable phrase list feature as an additional bag of words that you are willing to add to LUIS existing vocabulary features. Think of a non-exchangeable as set of different words. Default value is true.
	IsExchangeable *bool `json:"isExchangeable,omitempty"`
}

// PhraseListFeatureInfo phraselist Feature.
type PhraseListFeatureInfo struct {
	autorest.Response `json:"-"`
	// Phrases - A list of comma-separated values.
	Phrases *string `json:"phrases,omitempty"`
	// IsExchangeable - An exchangeable phrase list feature are serves as single feature to the LUIS underlying training algorithm. It is used as a lexicon lookup feature where its value is 1 if the lexicon contains a given word or 0 if it doesn’t. Think of an exchangeable as a synonyms list. A non-exchangeable phrase list feature has all the phrases in the list serve as separate features to the underlying training algorithm. So, if you your phrase list feature contains 5 phrases, they will be mapped to 5 separate features. You can think of the non-exchangeable phrase list feature as an additional bag of words that you are willing to add to LUIS existing vocabulary features. Think of a non-exchangeable as set of different words. Default value is true.
	IsExchangeable *bool `json:"isExchangeable,omitempty"`
	// ID - A six-digit ID used for Features.
	ID *int32 `json:"id,omitempty"`
	// Name - The name of the Feature.
	Name *string `json:"name,omitempty"`
	// IsActive - Indicates if the feature is enabled.
	IsActive *bool `json:"isActive,omitempty"`
}

// PhraselistUpdateObject object model for updating a Phraselist.
type PhraselistUpdateObject struct {
	// Phrases - List of comma-separated phrases that represent the Phraselist.
	Phrases *string `json:"phrases,omitempty"`
	// Name - The Phraselist name.
	Name *string `json:"name,omitempty"`
	// IsActive - Indicates if the Phraselist is enabled.
	IsActive *bool `json:"isActive,omitempty"`
	// IsExchangeable - An exchangeable phrase list feature are serves as single feature to the LUIS underlying training algorithm. It is used as a lexicon lookup feature where its value is 1 if the lexicon contains a given word or 0 if it doesn’t. Think of an exchangeable as a synonyms list. A non-exchangeable phrase list feature has all the phrases in the list serve as separate features to the underlying training algorithm. So, if you your phrase list feature contains 5 phrases, they will be mapped to 5 separate features. You can think of the non-exchangeable phrase list feature as an additional bag of words that you are willing to add to LUIS existing vocabulary features. Think of a non-exchangeable as set of different words. Default value is true.
	IsExchangeable *bool `json:"isExchangeable,omitempty"`
}

// PrebuiltDomain prebuilt Domain.
type PrebuiltDomain struct {
	Name        *string               `json:"name,omitempty"`
	Culture     *string               `json:"culture,omitempty"`
	Description *string               `json:"description,omitempty"`
	Examples    *string               `json:"examples,omitempty"`
	Intents     *[]PrebuiltDomainItem `json:"intents,omitempty"`
	Entities    *[]PrebuiltDomainItem `json:"entities,omitempty"`
}

// PrebuiltDomainCreateBaseObject a model object containing the name of the custom prebuilt entity and the name of
// the domain to which this model belongs.
type PrebuiltDomainCreateBaseObject struct {
	// DomainName - The domain name.
	DomainName *string `json:"domainName,omitempty"`
}

// PrebuiltDomainCreateObject a prebuilt domain create object containing the name and culture of the domain.
type PrebuiltDomainCreateObject struct {
	// DomainName - The domain name.
	DomainName *string `json:"domainName,omitempty"`
	// Culture - The culture of the new domain.
	Culture *string `json:"culture,omitempty"`
}

// PrebuiltDomainItem ...
type PrebuiltDomainItem struct {
	Name        *string `json:"name,omitempty"`
	Description *string `json:"description,omitempty"`
	Examples    *string `json:"examples,omitempty"`
}

// PrebuiltDomainModelCreateObject a model object containing the name of the custom prebuilt intent or entity and
// the name of the domain to which this model belongs.
type PrebuiltDomainModelCreateObject struct {
	// DomainName - The domain name.
	DomainName *string `json:"domainName,omitempty"`
	// ModelName - The intent name or entity name.
	ModelName *string `json:"modelName,omitempty"`
}

// PrebuiltEntityExtractor prebuilt Entity Extractor.
type PrebuiltEntityExtractor struct {
	autorest.Response `json:"-"`
	// ID - The ID of the Entity Model.
	ID *uuid.UUID `json:"id,omitempty"`
	// Name - Name of the Entity Model.
	Name *string `json:"name,omitempty"`
	// TypeID - The type ID of the Entity Model.
	TypeID *int32 `json:"typeId,omitempty"`
	// ReadableType - Possible values include: 'ReadableTypeEntityExtractor', 'ReadableTypeHierarchicalEntityExtractor', 'ReadableTypeHierarchicalChildEntityExtractor', 'ReadableTypeCompositeEntityExtractor', 'ReadableTypeClosedListEntityExtractor', 'ReadableTypePrebuiltEntityExtractor', 'ReadableTypeIntentClassifier'
	ReadableType ReadableType `json:"readableType,omitempty"`
}

// ProductionOrStagingEndpointInfo ...
type ProductionOrStagingEndpointInfo struct {
	autorest.Response `json:"-"`
	// VersionID - The version ID to publish.
	VersionID *string `json:"versionId,omitempty"`
	// IsStaging - Indicates if the staging slot should be used, instead of the Production one.
	IsStaging *bool `json:"isStaging,omitempty"`
	// EndpointURL - The Runtime endpoint URL for this model version.
	EndpointURL *string `json:"endpointUrl,omitempty"`
	// Region - The target region that the application is published to.
	Region *string `json:"region,omitempty"`
	// AssignedEndpointKey - The endpoint key.
	AssignedEndpointKey *string `json:"assignedEndpointKey,omitempty"`
	// EndpointRegion - The endpoint's region.
	EndpointRegion *string `json:"endpointRegion,omitempty"`
	// PublishedDateTime - Timestamp when was last published.
	PublishedDateTime *string `json:"publishedDateTime,omitempty"`
}

// ReadCloser ...
type ReadCloser struct {
	autorest.Response `json:"-"`
	Value             *io.ReadCloser `json:"value,omitempty"`
}

// SetString ...
type SetString struct {
	autorest.Response `json:"-"`
	Value             map[string]*string `json:"value"`
}

// MarshalJSON is the custom marshaler for SetString.
func (ss SetString) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if ss.Value != nil {
		objectMap["value"] = ss.Value
	}
	return json.Marshal(objectMap)
}

// String ...
type String struct {
	autorest.Response `json:"-"`
	Value             *string `json:"value,omitempty"`
}

// SubClosedList sublist of items for a Closed list.
type SubClosedList struct {
	// CanonicalForm - The standard form that the list represents.
	CanonicalForm *string `json:"canonicalForm,omitempty"`
	// List - List of synonym words.
	List *[]string `json:"list,omitempty"`
}

// SubClosedListResponse sublist of items for a Closed list.
type SubClosedListResponse struct {
	// ID - The sublist ID
	ID *int32 `json:"id,omitempty"`
	// CanonicalForm - The standard form that the list represents.
	CanonicalForm *string `json:"canonicalForm,omitempty"`
	// List - List of synonym words.
	List *[]string `json:"list,omitempty"`
}

// TaskUpdateObject object model for cloning an application's version.
type TaskUpdateObject struct {
	// Version - The new version for the cloned model.
	Version *string `json:"version,omitempty"`
}

// UserAccessList list of user permissions.
type UserAccessList struct {
	autorest.Response `json:"-"`
	// Owner - The email address of owner of the application.
	Owner  *string   `json:"owner,omitempty"`
	Emails *[]string `json:"emails,omitempty"`
}

// UserCollaborator ...
type UserCollaborator struct {
	// Email - The email address of the user.
	Email *string `json:"email,omitempty"`
}

// UUID ...
type UUID struct {
	autorest.Response `json:"-"`
	Value             *uuid.UUID `json:"value,omitempty"`
}

// VersionInfo object model of an application version.
type VersionInfo struct {
	autorest.Response `json:"-"`
	// Version - The version ID. E.g.: "0.1"
	Version *string `json:"version,omitempty"`
	// CreatedDateTime - The version's creation timestamp.
	CreatedDateTime *date.Time `json:"createdDateTime,omitempty"`
	// LastModifiedDateTime - Timestamp of the last update.
	LastModifiedDateTime *date.Time `json:"lastModifiedDateTime,omitempty"`
	// LastTrainedDateTime - Timestamp of the last time the model was trained.
	LastTrainedDateTime *date.Time `json:"lastTrainedDateTime,omitempty"`
	// LastPublishedDateTime - Timestamp when was last published.
	LastPublishedDateTime *date.Time `json:"lastPublishedDateTime,omitempty"`
	// EndpointURL - The Runtime endpoint URL for this model version.
	EndpointURL *string `json:"endpointUrl,omitempty"`
	// AssignedEndpointKey - The endpoint key.
	AssignedEndpointKey map[string]*string `json:"assignedEndpointKey"`
	// ExternalAPIKeys - External keys.
	ExternalAPIKeys interface{} `json:"externalApiKeys,omitempty"`
	// IntentsCount - Number of intents in this model.
	IntentsCount *int32 `json:"intentsCount,omitempty"`
	// EntitiesCount - Number of entities in this model.
	EntitiesCount *int32 `json:"entitiesCount,omitempty"`
	// EndpointHitsCount - Number of calls made to this endpoint.
	EndpointHitsCount *int32 `json:"endpointHitsCount,omitempty"`
	// TrainingStatus - The current training status. Possible values include: 'NeedsTraining', 'InProgress', 'Trained'
	TrainingStatus TrainingStatus `json:"trainingStatus,omitempty"`
}

// MarshalJSON is the custom marshaler for VersionInfo.
func (vi VersionInfo) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if vi.Version != nil {
		objectMap["version"] = vi.Version
	}
	if vi.CreatedDateTime != nil {
		objectMap["createdDateTime"] = vi.CreatedDateTime
	}
	if vi.LastModifiedDateTime != nil {
		objectMap["lastModifiedDateTime"] = vi.LastModifiedDateTime
	}
	if vi.LastTrainedDateTime != nil {
		objectMap["lastTrainedDateTime"] = vi.LastTrainedDateTime
	}
	if vi.LastPublishedDateTime != nil {
		objectMap["lastPublishedDateTime"] = vi.LastPublishedDateTime
	}
	if vi.EndpointURL != nil {
		objectMap["endpointUrl"] = vi.EndpointURL
	}
	if vi.AssignedEndpointKey != nil {
		objectMap["assignedEndpointKey"] = vi.AssignedEndpointKey
	}
	objectMap["externalApiKeys"] = vi.ExternalAPIKeys
	if vi.IntentsCount != nil {
		objectMap["intentsCount"] = vi.IntentsCount
	}
	if vi.EntitiesCount != nil {
		objectMap["entitiesCount"] = vi.EntitiesCount
	}
	if vi.EndpointHitsCount != nil {
		objectMap["endpointHitsCount"] = vi.EndpointHitsCount
	}
	if vi.TrainingStatus != "" {
		objectMap["trainingStatus"] = vi.TrainingStatus
	}
	return json.Marshal(objectMap)
}

// WordListBaseUpdateObject object model for updating one of the closed list's sublists.
type WordListBaseUpdateObject struct {
	// CanonicalForm - The standard form that the list represents.
	CanonicalForm *string `json:"canonicalForm,omitempty"`
	// List - List of synonym words.
	List *[]string `json:"list,omitempty"`
}

// WordListObject sublist of items for a Closed list.
type WordListObject struct {
	// CanonicalForm - The standard form that the list represents.
	CanonicalForm *string `json:"canonicalForm,omitempty"`
	// List - List of synonym words.
	List *[]string `json:"list,omitempty"`
}
